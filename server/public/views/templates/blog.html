
<div layout="row" class="wholeEnchilada">
  <div layout="column" flex="15" ng-controller="NavController as nc">


    <div class="sideNavHolder">
      <div class="sideNav">
        <div class="clickMe" ng-click="nc.goHome()">About Me</div>
      </div>
      <div class="sideNav">
        <div class="clickMe alive" ng-click="nc.goBlog()">Blog</div>
      </div>
      <div class="sideNav">
        <div class="clickMe" ng-click="nc.goPort()">Portfolio</div>
      </div>
    </div>

  </div>

  <div class="blogContent" layout="column" flex="60">
    <!-- <h1>blog</h1> -->

<!-- <div layout layout-align="center center">
  <canvas id="triangle" width="300" height="300"></canvas>

</div> -->

<hr>

<div layout="column" layout-align="center center" id="post5">
  <div >
    <h2 class="blogTitle">Exploring the Golden Ratio</h2>
    <!-- <a name="chapter1"></a> -->
  </div>
  <div class="blogSubtitle">
    Dec. 18, 2017
  </div>
</div>

<div class="blogText">
  The golden ratio, commonly denoted &Phi;, shows up throughout nature and the human arts. It is one of the most breathtaking pieces of math I've encountered.
</div>

<div class="blogText">
  If you begin with a line segment and then cut it at some point, you will have two shorter line segments. The lengths of those segments are in the golden ratio when the shorter line segment (of length <i>b</i>) stands to the longer line segment (of length <i>a</i>) as the longer line segment stands to the whole (<i>a + b</i>). That is, <i>a</i> and <i>b</i> exemplify the golden ratio (i.e. <i>a</i>/<i>b</i> = &Phi;) if
</div>

<!-- Lot of work just for an equation: -->
<div class="blogText">
  <div layout="row" layout-align="center center">
    <div layout="column">
      <div layout="row" layout-align="center center">
        <i>a</i> &ensp;+&ensp; <i>b</i>
      </div>
      <div layout="row" layout-align="center center" class="lowCeiling">
        &mdash;&mdash;
      </div>
      <div layout="row" layout-align="center center">
        <i>a</i>
      </div>
    </div>
    <div layout="column">
      &emsp;=&emsp;
    </div>
    <div layout="column">
      <div layout="row" layout-align="center center">
        <i>a</i>
      </div>
      <div layout="row" layout-align="center center" class="lowCeiling">
        &mdash;
      </div>
      <div layout="row" layout-align="center center">
        <i>b</i>
      </div>
    </div>
  </div>
</div>

<div layout layout-align="center center">
  <canvas id="line" width="400" height="40"></canvas>
</div>

<div class="blogText">
  If we let the smaller length, <i>b</i>, be equal to 1, a bit of algebra reveals that &Phi;<sup>2</sup> = &Phi; + 1. Solving this, we get an approximation for &Phi;: 1.618.
</div>

<div class="blogText">
  If we imagine this divided line bending around to form a circle, we get what is sometimes called the golden angle, 2&Pi;/&Phi; radians. Many plants have leaves that grow in this pattern, probably in order to maximize sun-exposed surface area. We might draw the first two petals or leaves like this:
</div>

<div layout layout-align="center center">
  <canvas id="twoLeaves" width="500" height="500"></canvas>
</div>

<div class="blogText">
  Each leaf is composed of two circular arcs; we draw one leaf, and then <span class="codeBit">ctx.rotate(Math.PI/1.618)</span>, and draw another slightly shorter leaf.
</div>

<pre><code layout layout-align="center center">function drawLeaf(l) {
  var r = l * 1.5;
  var theta = Math.asin(l/r);
  //draw first half of leaf:
  ctx.beginPath();
  ctx.arc(Math.pow((r*r - l*l), 0.5), -l, r, Math.PI - theta, Math.PI + theta);
  ctx.stroke();

  //draw second half of leaf:
  ctx.beginPath();
  ctx.arc(-Math.pow((r*r - l*l), 0.5), -l, r, -theta, theta);
  ctx.stroke();
}
</code></pre>

<div class="blogText">
  To draw a more full-bodied plant, we just need a <span class="codeBit">for</span> loop:
</div>

<pre><code layout layout-align="center center">for (var i=0; i<20; i++) {
    drawLeaf(startLength);
    ctx9.rotate(2*Math.PI/phi);
    startLength *= 0.88;
  }
</code></pre>

<div layout layout-align="center center">
  <canvas id="golden" width="500" height="500"></canvas>

</div>

<div class="blogText">
  Bromiliads provide an especially vivid illustration of this principle at work:
</div>

<div layout="row" layout-align="center center">
  <img class="bromiliad" src="styles/bromiliad2.jpg" alt="">&emsp;
  <img class="bromiliad" src="styles/bromiliad.jpg" alt="">
</div>

<hr>

<div layout="column" layout-align="center center" id="post4">
  <div >
    <h2 class="blogTitle">Writing SQL Queries</h2>
    <!-- <a name="chapter1"></a> -->
  </div>
  <div class="blogSubtitle">
    Dec. 17, 2017
  </div>
</div>

<div class="blogText">
  Writing queries to your SQL database is a lot of fun, and pretty intuitive once you get used to the syntax. (We'll use PostgreSQL syntax here.)
</div>

<div class="blogText">
  To my mind, the bread and butter of a relational database query is the <span class="codeBit">JOIN</span> keyword. Suppose we have one table to keep track of humanitarian projects and another table, keyed to the first table, to keep track of each project's monthly carbon footprint. (Incidentally, this is the group project I'm working on at Prime.) To get all of the footprints associated with a single project, we could write
</div>

<pre><code layout layout-align="center center">SELECT * FROM "projects" JOIN "footprints"
  ON "projects"."id" = "footprints"."project_id"
  WHERE "projects"."id" = 1;
</code></pre>

<div class="blogText">
  The <span class="codeBit">ON</span> clause ensures that we grab all of the footprints that have a project_id value equal to the id of the project we are interested in. A potential problem with this is that we might have identically-named columns in different tables (e.g. "id"). To remedy this, we can replace <span class="codeBit">*</span> in our <span class="codeBit">SELECT</span> clause with <span class="codeBit">"footprints"."id" as footprint_id, "projects"."id" as project_id, "living_total", "shipping_total", "travel_total"</span>.
</div>

<div class="blogText">
  Our footprints table might have many rows; suppose we want to sum up the values in each column across all rows. We could write
</div>

<pre><code layout layout-align="center center">SELECT SUM("living_total") as living_total,
  SUM("travel_total") as travel_total,
  SUM("shipping_total") as shipping_total
  FROM "footprints";
</code></pre>

<div class="blogText">
  If we want to sum the values across columns, we can write <span class="codeBit">SUM("travel_total" + "shipping_total" + "living_total") as "total_footprint"</span>.
</div>

<div class="blogText">
  Suppose that instead of summing all the rows, we wanted to group them into clusters, for instance by footprint Type. We can pair the <span class="codeBit">SUM</span> keyword with <span class="codeBit">PARTITION BY</span> to accomplish that: <span class="codeBit">SELECT SUM("living_total") OVER (PARTITION BY "type")</span>.
</div>

<div class="blogText">
  Suppose we have three other tables, Shipping, Living and Travel, each keyed to our Footprints table. In order to post a new footprint to the database, we need to update each table. In our query from the server, we would first post to the Footprints table, adding <span class="codeBit">RETURNING "id"</span> to our <span class="codeBit">INSERT INTO</span> query. Then we can pass the returned id along to the next query, which posts to our three subtables with the proper foreign key.
</div>

<div class="blogText">
  Finally, suppose we want to get, for each project, an array of all the footprint totals associated with it. The query would look something like this:
</div>

<pre><code layout layout-align="center center">SELECT "projects"."name" as name, array_agg("footprint_total") as total
  FROM "projects" JOIN "footprints"
  ON "projects"."id" = "footprints"."project_id"
  GROUP BY "projects"."name";
</code></pre>


<hr>

<div layout="column" layout-align="center center" id="post3">
  <div >
    <h2 class="blogTitle">Getting Started with Matter.js</h2>
    <a name="chapter1"></a>
  </div>
  <div class="blogSubtitle">
    Dec. 16, 2017
  </div>
</div>

<div class="blogText">
  Matter.js is a super fun physics library with excellent documentation (<a href="http://brm.io/matter-js/docs/">Matter.js</a>) that can be easily added into a project. Simply <span class="codeBit">npm install matter-js</span> and source matter.min.js into your index.
</div>

<div class="blogText">
  I've found it easier to get Matter.js up and running when I use it in conjunction with <a href="http://p5js.org">p5.js</a> to draw bodies on the canvas. Matter.js can be broken into two functional components: an engine for calculating all the physics, and a renderer for drawing bodies on the canvas. Instead of using Matter's built-in renderer, we can use p5. (Just run another <span class="codeBit">npm install</span> and source it in).
</div>

<div class="blogText">
  The following code will add a falling square and a static circle to the canvas. To start off, we can add a few abbreviations to save some time later on:
</div>

<pre><code layout layout-align="center center">var Engine = Matter.Engine;
var World = Matter.World;
var Bodies = Matter.Bodies;
</code></pre>

<div class="blogText">
 Then we can add a few bodies ...
</div>

<pre><code layout layout-align="center center">var box1 = Bodies.rectangle(200, 100, 20, 20);
var omega = Bodies.circle(500, 500, 100, {isStatic: true});
</code></pre>

<div class="blogText">
  The last (optional) argument passed to the shape constructor is an <span class="codeBit">options</span> object. Setting <span class="codeBit">isStatic</span> to 'true' makes the body immobile; if we set <span class="codeBit">isSensor</span> to 'true', the body won't participate in any collisions.
</div>
<div class="blogText">
  But we mustn't forget to <span class="codeBit">add</span> the bodies to our <span class="codeBit">world</span>! p5.js asks for two things: a <span class="codeBit">setup</span> function to tell it how to render the initial page, and a <span class="codeBit">draw</span> function to tell it how to update the canvas as time goes on:
</div>

<pre><code layout layout-align="center center">function setup() {
  var canvas = createCanvas(1000,1000);
  var engine = Engine.create();
  var world = engine.world;
  World.add(world, [box1, omega]);
  Engine.run(engine);
}
</code></pre>

<div class="blogText">
  After we create our engine and our world, and start our engine, we're ready to draw:

</div>

<pre><code layout layout-align="center center">function draw() {
  background(251);
  rect(box1.position.x, box1.position.y, 20, 20);
  ellipse(omega.position.x, omega.position.y, 200);
}
</code></pre>

<div class="blogText">
  We reset the background with every iteration of the <span class="codeBit">draw</span> function in order to clear the previous renderings -- otherwise we end up with space-time worms roaming through our canvas.
</div>

<div class="blogText">
  An important thing to note when using p5.js in conjunction with Matter.js is that they keep track of bodies differently. For instance, p5's <span class="codeBit">ellipse</span> function asks for the body's diameter, whereas Matter's <span class="codeBit">circle</span> function asks for the body's radius. Another example of this misalignment is that Matter tracks the position of rectangles by their centers, while p5 (as well as vanilla canvas) tracks them by their upper-left corners.
</div>

<div class="blogText">
  At this point, the possibilities proliferate. With <span class="codeBit">Matter.Mouse</span> and <span class="codeBit">Matter.MouseConstraint</span>, you can allow the user to interact with your world's bodies. With <span class="codeBit">Matter.Events</span> you can listen for collisions. With <span class="codeBit">Matter.Constraint</span> you can attach bodies to each other. Matter even lets you alter the world's gravity (with <span class="codeBit">world.gravity.y</span>)!
</div>

<div class="blogText">
  And p5 is no slouch. It offers <span class="codeBit">mouseClicked</span> and <span class="codeBit">mouseDragged</span> functions that make it easy to interact with the canvas. If you add an array to your global scope...</div>
  <pre><code layout layout-align="center center">var balls = [];
  </code></pre>


  <div class="blogText">...and then add a loop into your <span class="codeBit">draw</span> function...:
</div>
<pre><code layout layout-align="center center" id="hardCode">{{bc.hardText}}
</code></pre>

  <div class="blogText">...then finally, you can add a <span class="codeBit">mouseDragged</span> function like so:
  </div>
  <pre><code layout layout-align="center center">function mouseDragged() {
    var randomNum = Math.random()*50;
    var ball = Bodies.circle(mouseX, mouseY, randomNum);
    console.log(ball);
    World.add(world, ball);
    balls.push(ball);
}</code></pre>
  <div class="blogText">
    The possibilities sprawl before us!
</div>

<hr>

<div layout="column" layout-align="center center" id="post2">
  <div >
    <h2 class="blogTitle">More HTML Canvas: Fun with Conic Sections</h2>

  </div>
  <div class="blogSubtitle">
    Dec. 14, 2017
  </div>
</div>

    <!-- parabola defn  -->
<div class="blogText">
  Now that we're familiar with the basic tools of the canvas, we can illustrate some cool facts about conic sections. For instance, we can spin up a nice visualization of the parabola's defining property. Every parabola has a focus and a directrix, and obeys the rule that every point on the parabola is equidistant from the parabola's focus and its directrix (pictured as a dotted line).
</div>

<div layout layout-align="center center">
  <canvas id='ball' height=800 width =800></canvas>
  &emsp; <md-slider ng-model="bc.x" ng-change="bc.drawBall(bc.x)" min="250" max="750" aria-label="parabDefn"></md-slider>
</div>


    <!-- ellipse defn  -->

<div class="blogText">
        Similarly, we can dynamically illustrate the defining property of an ellipse: each point on an elliptical path obeys the rule that the sum of its distances from the foci is constant.
        <!-- One can imagine a string stretched from one focus to the ball to the other focus, retaining its length throughout the ball's path. -->
</div>

<div class="blogText">
  We use the parametric equations for an ellipse,
  <div layout layout-align="center center" class="math">
    <i>x(t) = acos(t)<br>y(t) = bsin(t)</i>
  </div>to draw the ball that follows our elliptical path:

<pre><code layout layout-align="center center">ctx.beginPath();
  var x = 250*a*Math.cos((theta/100));
  var y = 250*b*Math.sin(theta/100);
  ctx.arc(x, y, 10, 0, 2*Math.PI);
  ctx.stroke();
  ctx.fillStyle = 'yellow';
  ctx.fill();
</code></pre>

</div>

<div class="blogText">
  If we also draw in the ellipse's tangent at each point, we have an illustration of the fact that an ellipse's focal lines (lines from each focus to a point on the ellipse) make equal angles with the ellipse's tangent.
</div>



<div layout="row">
  <div flex="70" layout layout-align="center center">
    <canvas id="ellipse" width="700" height="700"></canvas>
  </div>
  <div layout="column" flex="30">
    <br><br>
    <div>
        Horizontal Stretch:<md-slider min="25" max="200" ng-model="bc.a" ng-change="bc.drawEllipse(bc.a/100, bc.b/100, bc.theta)" aria-label="ellipseA"></md-slider>
    </div>
    <div>
        Vertical Stretch: <md-slider min="25" max="200" ng-model="bc.b" ng-change="bc.drawEllipse(bc.a/100, bc.b/100, bc.theta)" aria-label="ellipseB"></md-slider>
    </div>
    <div>
        Ball's Position: <md-slider min="0" max="628" ng-model="bc.theta" ng-change="bc.drawEllipse(bc.a/100, bc.b/100, bc.theta)" aria-label="ellipseTheta"></md-slider>
    </div>
    <div>
      <button ng-click="bc.toggleTangent()">Show tangent</button>

    </div>
  </div>
</div>

<div class="blogText">
  Another way of saying it is: were you to send a ball toward an elliptical wall from one of its foci, the ball would bounce off of the wall and end up at the other focus. In the same way, sound waves bounce off the walls of elliptical rooms called "<a href="https://en.wikipedia.org/wiki/Whispering_gallery">whispering rooms</a>", allowing people standing at one focus to hear what is whispered by someone standing at the other focus!
</div>

    <div class="blogText">
          Similarly, balls shot out of a parabola's focus will bounce off its wall and shoot straight down, in a path perpendicular to the directrix. Said another way, all light rays passing into a parabolic shape will reflect off the wall and pass through its focus.
    </div>



    <div layout layout-align="center center">
      <canvas id="parabReflection" width="800" height="800"></canvas>
      &emsp; <md-slider min="250" max="750" ng-model="bc.x4" ng-change="bc.drawBall4(bc.x4)" aria-label="parabReflection"></md-slider>
    </div>




    <!-- parabola orthogonal -->

<div class="blogText">
   Finally, we can illustrate the fact that a parabola's orthogonal tangents intersect on the directrix. Moreover, the line connecting two points on the parabola that have orthogonal tangents will always contain the focus! So there are an infinite number of right triangles living between a parabola and its directrix.
</div>

<div layout layout-align="center center">
  <canvas id="parabOrth" width="800" height="800"></canvas>
    &emsp;<md-slider min="250" max="493" ng-model="bc.x3" ng-change="bc.drawBall3(bc.x3)" aria-label="parabolaOrth"></md-slider>
</div>











<hr>


<div layout="column" layout-align="center center" id="post1">
  <h2 class="blogTitle">Getting Started with HTML Canvas Animations</h2>
  <div class="blogSubtitle">Dec. 12, 2017</div>
</div>



    <div class="blogText">
      Being something of a math/physics nerd, I was delighted to discover that with just the HTML canvas element, vanilla JavaScript, and a bit of math, one can easily render pleasing visual illustrations of key mathematical relationships.
    </div>

    <!-- ball throw -->

    <div class="blogText">
      For instance, one can illustrate a ball following a parabolic path. To describe the shape of a parabola, you just need a quadratic equation:
      <div layout layout-align="center center" class="math">
        <i>f(x) = ax<sup>2</sup> + bx + c</i>
      </div>
      As a bonus, since one natural way of writing the code ensures that the x-value changes linearly (at a constant rate), the ball will behave as if it is under the influence of gravity!
    </div>

    <pre><code layout layout-align="center center">
    vm.x = 0;
    function ball() {
        ctx.clearRect(0,0,400,400);
        var xStandard = (vm.x - 200)/100;
        var yPix = Math.pow(xStandard, 2)*100;
        ctx.translate(200, 0);
        ctx.beginPath();
        ctx.arc(xStandard*100, yPix, 5, 0, 2*Math.PI);
        ctx.stroke();
        ctx.fillStyle = 'purple';
        ctx.fill();
        ctx.translate(-200, 0);
        vm.x += 5;
      }</code></pre>

      <div class="blogText">
        This function keeps track of the ball's position. We can call it many times per second, each time clearing the canvas and re-drawing the ball at a slightly different position.
      </div>

      <div class="blogText">
        Canvas's coordinate system starts at the upper lefthand corner; the value of <i>y</i> increases as you move further down the screen, and <i>x</i>'s value increases as you move right.
      </div>

      <div class="blogText"> We translate to a new origin to simplify our calculation, moving to the middle of the top of our 400x400 canvas, to (200, 0). <i>(Don't forget to translate back out before re-drawing the ball!)</i>. Then we divide by 100 to standardize our units before squaring the value of the ball's x-coordinate, which gives us the ball's y-coordinate.</div>

      <div class="blogText">
        Now that we know the ball's position, it's straightforward to draw it: we begin a new path, call canvas's <span class="codeBit">arc()</span> method, draw the ball's outline with <span class="codeBit">stroke()</span>, and color it in with <span class="codeBit">fill()</span>. Finally, we ensure our function is called every 50 milliseconds:
      </div>

      <pre><code layout layout-align="center center">vm.throwBall = function() {
        setInterval(ball, 50);
      };</code></pre>

    <div layout layout-align="center center">
      <canvas id="parabolaBall" width="400" height="400"></canvas>
      &emsp;<button ng-click="bc.throwBall()">Throw</button>

    </div>


    <!-- parabola  -->
    <div class="blogText">
      To draw a parabolic curve onto the canvas requires a bit more thought. Canvas has built-in functions to draw circular and elliptical arcs, but if you want to draw a specific curve, you need to break things down into small intervals (borrowing an idea from calculus) and connect the dots with straight lines. When the intervals are small enough, the concatentation of straight lines will appear curve-like.

    </div>

    <pre><code layout layout-align="center center">function parabola(x, L, a, dir) {
        for (var i = 0; i < x; i++) {
          ctx.moveTo(i*L + dir*200, a*Math.pow(i*L/100, 2)*100 + i*L + 100);
          ctx.lineTo((i+1)*L + dir*200, a*Math.pow((i+1)*L/100, 2)*100 + (i+1)*L + 100);
          ctx.stroke();
        }
      }</code></pre>

      <div class="blogText">
        In this function, <i>x</i> controls the number of iterations, and <i>L</i> controls the length of the line segment that is drawn during each iteration. We're hard-coding in the values of <i>b</i> and <i>c</i>. The idea is to begin the line (with <span class="codeBit">moveTo()</span>) at one point on the parabola, and end it at a nearby point on the parabola with <span class="codeBit">lineTo()</span>. Remember to draw the line with <span class="codeBit">stroke()</span>!

      </div>

        <div class="blogText">We use canvas's built-in linear transformation function to reflect the first half of the parabola over the y-axis:

      </div>

      <pre><code layout layout-align="center center">ctx.transform(-1, 0, 0, 1, 0, 0);</code></pre>

      <div class="blogText">
        Don't forget to transform again when you're done drawing the second half &mdash; otherwise all your future commands will assume your canvas is still flipped over. (You can use the same function, since the transformation is symmetric.)
      </div>

    <div layout layout-align="center center">
      <canvas id="parabola" width="400" height="400"></canvas>
      &emsp;&emsp;<md-slider ng-model="bc.params.p" min="5" max="500" ng-change="bc.parabola2(200,1,1/(bc.params.p*4/100),0,0,1)" aria-label="parab"></md-slider>
    </div>

    <!-- polygon -->
    <div layout layout-align="center center" class="blogText">
      We can apply the same principle to write a function that draws a circle or an ellipse (as well as any regular polygon!). As we increase the number of sides (represented in this function by the argument x), the shape appears more curve-like.
    </div>

    <pre><code layout layout-align="center center">function circle(a, b, x, r) {
        ctx.beginPath();
        for (var i = 0; i < x; i++) {
          ctx.moveTo(r*a*Math.cos(i*2*Math.PI/x), r*b*Math.sin(i*2*Math.PI/x));
          ctx.lineTo(r*a*Math.cos((i+1)*2*Math.PI/x), r*b*Math.sin((i+1)*2*Math.PI/x));
          ctx.stroke();
        }
      }</code></pre>


    <div layout layout-align="center center">
      <canvas id="polygon" width="400" height="400"></canvas>
          &emsp;&emsp;<md-slider ng-model="bc.n" min="2" max="18" ng-change="bc.drawPolygon(bc.n)" aria-label="polygon"></md-slider>
    </div>

    <div class="blogText">
      One key thing to note here is the <span class="codeBit">beginPath</span> function. Often you will want to clear your canvas (with a <span class="codeBit">clearRect()</span> method call), and in order to draw on your freshly cleared canvas you will need to begin a new path.
    </div>





  </div>

  <div class="prevPosts" layout="column" flex="12">
    <div class="allposts" layout layout-align="center center">All Posts:</div>
    <ul class="postlist">
      <li ng-click="bc.goToPost(5)">Exploring the Golden Ratio</li>
      <li ng-click="bc.goToPost(4)">Writing SQL Queries</li>
      <li ng-click="bc.goToPost(3)">Getting Started with Matter.js</li>
      <li ng-click="bc.goToPost(2)">More HTML Canvas: Fun with Conic Sections</li>
      <li ng-click="bc.goToPost(1)">Getting Started with HTML Canvas Animations</li>
    </ul>
  </div>
</div>
